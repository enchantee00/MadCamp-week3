<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Pixel Art Classroom with Multiplayer</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three/examples/js/controls/OrbitControls.js"></script>
    <script>
        const scene = new THREE.Scene();

        // 카메라 설정
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 5, 10);

        // 렌더러 설정
        const renderer = new THREE.WebGLRenderer({ antialias: false }); // 안티앨리어싱을 끔
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // 바닥 추가
        const floorGeometry = new THREE.PlaneGeometry(20, 20);
        const floorMaterial = new THREE.MeshBasicMaterial({ color: 0x808080 });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = - Math.PI / 2;
        scene.add(floor);

        // 벽 추가
        const wallMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });

        const backWall = new THREE.Mesh(new THREE.PlaneGeometry(20, 10), wallMaterial);
        backWall.position.set(0, 5, -10);
        scene.add(backWall);

        const frontWall = new THREE.Mesh(new THREE.PlaneGeometry(20, 10), wallMaterial);
        frontWall.position.set(0, 5, 10);
        frontWall.rotation.y = Math.PI;
        scene.add(frontWall);

        const leftWall = new THREE.Mesh(new THREE.PlaneGeometry(20, 10), wallMaterial);
        leftWall.position.set(-10, 5, 0);
        leftWall.rotation.y = Math.PI / 2;
        scene.add(leftWall);

        const rightWall = new THREE.Mesh(new THREE.PlaneGeometry(20, 10), wallMaterial);
        rightWall.position.set(10, 5, 0);
        rightWall.rotation.y = -Math.PI / 2;
        scene.add(rightWall);

        // 책상과 의자 추가
        const desks = [];
        function createDesk(x, z) {
            const deskGeometry = new THREE.BoxGeometry(2, 1, 1);
            const deskMaterial = new THREE.MeshBasicMaterial({ color: 0x8B4513 });
            const desk = new THREE.Mesh(deskGeometry, deskMaterial);
            desk.position.set(x, 0.5, z);
            scene.add(desk);
            desks.push(desk);

            const chairGeometry = new THREE.BoxGeometry(1, 0.5, 1);
            const chairMaterial = new THREE.MeshBasicMaterial({ color: 0x0000ff });
            const chair = new THREE.Mesh(chairGeometry, chairMaterial);
            chair.position.set(x, 0.25, z - 1.5);
            scene.add(chair);
        }

        // 책상과 의자 배치
        for (let i = -4; i <= 4; i += 2) {
            for (let j = -8; j <= 8; j += 4) {
                createDesk(i, j);
            }
        }

        // 문 추가
        const doorGeometry = new THREE.PlaneGeometry(2, 5);
        const doorMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
        const door = new THREE.Mesh(doorGeometry, doorMaterial);
        door.position.set(0, 2.5, 9.9); // 앞 벽에 문을 추가
        scene.add(door);

        // 텍스트 생성 함수
        function createTextSprite(message) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            context.font = 'Bold 20px Arial';
            context.fillStyle = 'rgba(255, 255, 255, 1.0)';
            context.fillText(message, 0, 20);

            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(2, 1, 1);
            return sprite;
        }

        // 캐릭터 추가 함수
        function createCharacter(id, isLocal = false) {
            const character = new THREE.Group();

            const bodyGeometry = new THREE.BoxGeometry(0.6, 1.2, 0.3);
            const bodyMaterial = new THREE.MeshBasicMaterial({ color: 0xffc0cb });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.6;
            character.add(body);

            const headGeometry = new THREE.BoxGeometry(0.6, 0.6, 0.6);
            const headMaterial = new THREE.MeshBasicMaterial({ color: 0xffe0bd });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 1.5;
            character.add(head);

            const leftEyeGeometry = new THREE.BoxGeometry(0.1, 0.1, 0.1);
            const leftEyeMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
            const leftEye = new THREE.Mesh(leftEyeGeometry, leftEyeMaterial);
            leftEye.position.set(-0.15, 1.6, 0.3);
            character.add(leftEye);

            const rightEyeGeometry = new THREE.BoxGeometry(0.1, 0.1, 0.1);
            const rightEyeMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
            const rightEye = new THREE.Mesh(rightEyeGeometry, rightEyeMaterial);
            rightEye.position.set(0.15, 1.6, 0.3);
            character.add(rightEye);

            const legGeometry = new THREE.BoxGeometry(0.2, 0.6, 0.2);
            const legMaterial = new THREE.MeshBasicMaterial({ color: 0x0000ff });
            const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
            leftLeg.position.set(-0.2, 0.3, 0);
            character.add(leftLeg);

            const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
            rightLeg.position.set(0.2, 0.3, 0);
            character.add(rightLeg);

            // 텍스트 스프라이트 추가
            const textSprite = createTextSprite(id);
            textSprite.position.set(0, 2.5, 0);
            character.add(textSprite);

            if (isLocal) {
                character.position.set(6, 0.6, -8); // 로컬 캐릭터 초기 위치 설정
            } else {
                character.position.set(6, 0.6, 0); // 다른 캐릭터 초기 위치 설정
            }
            scene.add(character);

            if (isLocal) {
                localCharacter = character;
            } else {
                players[id] = character;
            }

            return character;
        }

        let localCharacter = null; // 로컬 캐릭터 변수
        const players = {}; // 다른 플레이어들을 저장할 객체

        // WebSocket 연결 설정
        const ws = new WebSocket('ws://143.248.226.15:8080');

        ws.onopen = () => {
            ws.id = Date.now(); // 간단한 클라이언트 식별자 설정
            createCharacter(ws.id, true); // 로컬 캐릭터 생성
        };

        ws.onmessage = (message) => {
            const data = JSON.parse(message.data);
            console.log(data);
            if (data.type === 'init') {
                // 기존 플레이어 추가
                if (data.states) {
                    Object.keys(data.states).forEach(clientId => {
                        const state = data.states[clientId];
                        const character = createCharacter(clientId);
                        character.position.set(state.position.x, state.position.y, state.position.z);
                        character.rotation.y = state.rotation.y;
                    });
                }
            } else if (data.type === 'newPlayer') {
                // 새로운 플레이어 추가
                createCharacter(data.id);
            } else if (data.type === 'removePlayer') {
                // 플레이어 제거
                const player = players[data.id];
                if (player) {
                    scene.remove(player);
                    delete players[data.id];
                }
            } else if (data.type === 'update') {
                // 플레이어 위치 및 회전 업데이트
                // console.log(player);
                let player = players[data.id];
                if (player) {
                    player.position.set(data.position.x, data.position.y, data.position.z);
                    player.rotation.y = data.rotation.y;
                }
            }
        };

        ws.onclose = () => {
            Object.keys(players).forEach(id => {
                scene.remove(players[id]);
                delete players[id];
            });
        };

        // 키보드 입력 처리
        const keyState = {};
        window.addEventListener('keydown', (event) => {
            keyState[event.code] = true;
        });
        window.addEventListener('keyup', (event) => {
            keyState[event.code] = false;
        });

        // 충돌 감지 함수
        function detectCollision(object, targetArray) {
            const objectBox = new THREE.Box3().setFromObject(object);
            for (let i = 0; i < targetArray.length; i++) {
                const targetBox = new THREE.Box3().setFromObject(targetArray[i]);
                if (objectBox.intersectsBox(targetBox)) {
                    return true;
                }
            }
            return false;
        }

        // 캐릭터 이동 함수
        function moveCharacter() {
            if (!localCharacter) return;

            const speed = 0.1;
            let direction = new THREE.Vector3();

            if (keyState['ArrowUp'] || keyState['KeyW']) {
                direction.z -= speed;
            }
            if (keyState['ArrowDown'] || keyState['KeyS']) {
                direction.z += speed;
            }
            if (keyState['ArrowLeft'] || keyState['KeyA']) {
                direction.x -= speed;
            }
            if (keyState['ArrowRight'] || keyState['KeyD']) {
                direction.x += speed;
            }

            if (direction.length() > 0) {
                localCharacter.position.add(direction);
                localCharacter.rotation.y = Math.atan2(direction.x, direction.z);

                // 충돌 감지 및 처리
                if (detectCollision(localCharacter, desks) || localCharacter.position.x < -9.5 || localCharacter.position.x > 9.5 || localCharacter.position.z < -9.5 || (localCharacter.position.z > 9.5 && localCharacter.position.z < 10.5 && Math.abs(localCharacter.position.x) > 1)) {
                    localCharacter.position.sub(direction);
                } else {
                    ws.send(JSON.stringify({
                        id: ws.id,
                        position: {
                            x: localCharacter.position.x,
                            y: localCharacter.position.y,
                            z: localCharacter.position.z
                        },
                        rotation: {
                            y: localCharacter.rotation.y
                        }
                    }));
                }
            }
        }

        // 카메라가 로컬 캐릭터를 따라가도록 설정
        function followCharacter() {
            if (!localCharacter) return;

            camera.position.x = localCharacter.position.x;
            camera.position.z = localCharacter.position.z + 10;
            camera.position.y = localCharacter.position.y + 5;
            camera.lookAt(localCharacter.position);
        }

        // 애니메이션 루프
        function animate() {
            requestAnimationFrame(animate);
            moveCharacter(); // 로컬 캐릭터 이동
            followCharacter(); // 카메라가 로컬 캐릭터를 따라가도록 설정
            renderer.render(scene, camera);
        }
        animate();

        // 창 크기 조절 대응
        window.addEventListener('resize', () => {
            renderer.setSize(window.innerWidth, window.innerHeight);
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
        });
    </script>
</body>
</html>
